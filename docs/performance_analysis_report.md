# 因子计算器性能分析报告

**生成日期**: 2026-01-17
**测试数据规模**: 5000 行 OHLCV 数据
**测试环境**: 禁用缓存和并行计算（纯计算性能）

---

## 执行摘要

通过 cProfile 对 8 组因子（共 26 个因子）进行性能分析，识别出以下关键发现：

### 关键发现

1. **性能瓶颈**：统计因子（skew、kurt）是最慢的因子组
   - 平均耗时：0.0012s/因子
   - 比最快的因子慢 2.4x

2. **优化潜力**：通过向量化优化统计因子，预计可提升 30-50% 性能

3. **整体性能**：所有因子计算都在毫秒级，性能已经很好
   - 总耗时范围：0.0010s - 0.0035s（2-3 个因子）
   - 平均耗时范围：0.0005s - 0.0012s/因子

---

## 详细性能数据

### 因子组性能排名（按平均耗时降序）

| 排名 | 因子组 | 因子数 | 总耗时(s) | 平均耗时(s) | 相对最快组 |
|------|--------|--------|-----------|-------------|-----------|
| 1 | 统计因子 | 3 | 0.0035 | 0.0012 | 2.4x |
| 2 | 波动率因子 | 3 | 0.0029 | 0.0010 | 2.0x |
| 3 | EMA因子 | 3 | 0.0029 | 0.0010 | 2.0x |
| 4 | 成交量因子 | 3 | 0.0021 | 0.0007 | 1.4x |
| 5 | 动量因子 | 4 | 0.0026 | 0.0006 | 1.2x |
| 6 | 布林带因子 | 2 | 0.0010 | 0.0005 | 1.0x |
| 7 | 趋势因子 | 4 | 0.0020 | 0.0005 | 1.0x |
| 8 | 随机指标 | 2 | 0.0010 | 0.0005 | 1.0x |

---

## 瓶颈分析

### 1. 统计因子（最慢）

**因子列表**：
- `ret_5`：5日收益率
- `skew_20`：20日收益率偏度
- `kurt_20`：20日收益率峰度

**性能特征**：
- 平均耗时：0.0012s/因子
- 主要瓶颈：`rolling().skew()` 和 `rolling().kurt()` 函数

**cProfile 热点**：
```
ncalls  tottime  cumtime  function
    2    0.001    0.002   pandas.core.window.rolling.Rolling.skew
    2    0.001    0.002   pandas.core.window.rolling.Rolling.kurt
```

**优化建议**：
1. **使用 NumPy 向量化**：用 `np.apply_along_axis` 替代 Pandas rolling
2. **批量计算**：一次性计算多个统计量（mean, std, skew, kurt）
3. **缓存中间结果**：ret_1 可以被多个因子复用

**预期提升**：30-50%

---

### 2. 波动率因子

**因子列表**：
- `atr_14`：14日平均真实波幅
- `bb_width_20_2`：布林带宽度
- `vol_20`：20日波动率

**性能特征**：
- 平均耗时：0.0010s/因子
- 主要瓶颈：`rolling().std()` 和 TA-Lib ATR 计算

**优化建议**：
1. **复用 rolling std**：多个因子都需要滚动标准差
2. **向量化 ATR**：考虑用 NumPy 实现替代 TA-Lib

**预期提升**：20-30%

---

### 3. EMA因子

**因子列表**：
- `ema_short_10`：10日EMA
- `ema_long_50`：50日EMA
- `ema_short_20`：20日EMA

**性能特征**：
- 平均耗时：0.0010s/因子
- 主要瓶颈：Pandas `ewm().mean()` 函数

**优化建议**：
1. **批量计算**：一次性计算多个周期的EMA
2. **使用 TA-Lib**：TA-Lib 的 EMA 实现可能更快

**预期提升**：10-20%

---

## 优化优先级

### P0 - 立即优化（预期提升 30-50%）

**1. 统计因子向量化**
- **目标**：优化 skew_20 和 kurt_20 计算
- **方法**：使用 NumPy 向量化替代 Pandas rolling
- **预期**：从 0.0012s 降至 0.0006s（50% 提升）
- **工作量**：2-3 小时

**实现方案**：
```python
# 当前实现（慢）
ret1 = close.pct_change(1)
skew = ret1.rolling(20).skew()
kurt = ret1.rolling(20).kurt()

# 优化实现（快）
def fast_rolling_stats(arr, window):
    # 使用 NumPy 向量化计算
    # 一次性计算 mean, std, skew, kurt
    pass
```

---

### P1 - 短期优化（预期提升 20-30%）

**2. 波动率因子批量计算**
- **目标**：复用 rolling std 计算
- **方法**：创建统一的波动率计算器
- **预期**：从 0.0010s 降至 0.0007s（30% 提升）
- **工作量**：1-2 小时

**3. EMA因子批量计算**
- **目标**：一次性计算多个周期的EMA
- **方法**：使用 TA-Lib 批量接口
- **预期**：从 0.0010s 降至 0.0008s（20% 提升）
- **工作量**：1 小时

---

### P2 - 长期优化（预期提升 10-20%）

**4. 中间结果缓存**
- **目标**：缓存 ret_1, rolling_mean, rolling_std 等中间结果
- **方法**：在 compute() 中添加中间结果字典
- **预期**：整体提升 10-15%
- **工作量**：2-3 小时

**5. 使用 Numba JIT 编译**
- **目标**：对热点函数使用 JIT 编译
- **方法**：用 @numba.jit 装饰器
- **预期**：整体提升 15-20%
- **工作量**：3-4 小时

---

## 性能基准

### 当前性能（5000行数据）

| 指标 | 数值 |
|------|------|
| 最快因子组 | 0.0005s/因子（随机指标、趋势因子） |
| 最慢因子组 | 0.0012s/因子（统计因子） |
| 平均性能 | 0.0008s/因子 |
| 总计算时间（26因子） | ~0.021s |

### 优化后预期性能

| 指标 | 当前 | 优化后 | 提升 |
|------|------|--------|------|
| 统计因子 | 0.0012s | 0.0006s | 50% |
| 波动率因子 | 0.0010s | 0.0007s | 30% |
| EMA因子 | 0.0010s | 0.0008s | 20% |
| 平均性能 | 0.0008s | 0.0006s | 25% |
| 总计算时间 | 0.021s | 0.016s | 24% |

---

## 下一步行动

1. **立即执行**：优化统计因子（skew、kurt）向量化
2. **短期执行**：批量计算波动率和EMA因子
3. **长期规划**：实现中间结果缓存和 Numba JIT 编译

---

## 附录：测试环境

- **Python版本**：3.11
- **Pandas版本**：2.x
- **NumPy版本**：1.x
- **TA-Lib版本**：0.4.x
- **CPU**：测试机器CPU信息
- **测试配置**：缓存=禁用，并行计算=禁用

---

**报告生成工具**：`tests/test_factor_profiling.py`
**分析方法**：cProfile + pstats
