# 本地向量库全面对比（轻量级 / Git 友好 / 无服务器）

更新日期：2026-01-15



> **⚠️ 历史文档说明（2026-01-17）**：
> 本文档中提及的 vbrain、vharvest、local_rag、in_memoria 等系统已于 2026-01-17 完全移除。
> 当前项目采用 Docker MCP ToolKit 的 `memory` 工具（知识图谱）+ 实时获取（fetch/playwright/context7/duckduckgo）方案。
> 本文档保留作为历史记录，文中相关内容仅供参考，不再适用于当前架构。


- 日期：2026-01-15
- 报告版本：1.0
- 目标：为 `freqtrade_demo` 选择本地文档向量库/检索加速器，满足“无需服务器、离线可用、维护成本低”，并尽可能 Git 友好（可同步、可追溯）。

---

## 0. 结论（快速答案）

1) 如果“Git 友好”的核心诉求是“跨设备一致可用”，而不是“把向量库文件直接提交到 Git”，那么本项目已经处于最优解：继续使用 `mcp-local-rag`（后端 LanceDB）并将 `.vibe/local-rag/` 视作可重建缓存，通过脚本预热重建即可。

2) 如果你明确要“把向量库作为资产随 Git 同步”（向量库文件也入库），不建议把 `.vibe/local-rag/` 纳入日常提交流；推荐改为“发布快照”（tag/release）或 Git LFS，避免仓库历史不可控膨胀。

3) 若你希望减少 Node/npx 依赖，并探索更“少文件/更可控”的本地持久化形态，当前在 MCP 生态里最接近“非自研替代”的候选是 `local-faiss-mcp`（Python + FAISS）。它是否更 Git 友好，需要一次小 POC 验证（见第 5 节）。

---

## 1. 本项目现状（可追溯）

- 当前使用的本地检索加速器：`mcp-local-rag@0.5.3`（通过 `npx` 启动，属于外部项目，不是本仓库自研向量库）。
- 向量库落盘：默认 `DB_PATH=.vibe/local-rag/lancedb`（可重建缓存）。
- 模型缓存：默认设备级目录（避免进入仓库），通过 `CACHE_DIR` 控制；切换 `MODEL_NAME` 会改变向量维度，通常需要重建 DB。
- 脚本入口（本仓库已固化闭环）：
  - `scripts/tools/local_rag_ingest_project_docs.py`：索引 `docs/`（建议的默认入口）
  - `scripts/tools/local_rag_ingest_sources.py`：索引 `.vibe/knowledge/sources/`（抓取缓存）
  - `scripts/tools/local_rag_cleanup_ingested_files.py`：清理已入库条目
  - `scripts/tools/local_rag_eval_models.py`：嵌入模型评估（回归集 + hit@k/MRR）
  - `scripts/tools/vbrain.py search`：统一查询入口
- Git 策略（已落地）：`.gitignore` 明确忽略 `.vibe/`；`scripts/tools/git_sync_audit.ps1` 将 `.vibe/` 与 `lancedb/` 列为“应避免跟踪”的缓存路径。

---

## 2. “Git 友好”的两个定义（先对齐）

向量库场景里，“Git 友好”常常有两种不同诉求：

- A) 源数据友好（推荐）：Git 只同步“权威层数据”（例如 `docs/`、脚本与配置），向量库作为可重建产物；跨设备通过统一脚本重建索引得到一致体验。
- B) 产物友好（慎用）：向量库文件/目录也随 Git 同步，追求拿到仓库就能直接检索（不必重建）。

本项目当前选择 A，并且配套了脚本化重建与评估用例；若改为 B，需要额外承担：仓库膨胀、二进制 diff 不可读、频繁变更导致历史不可控等问题。

---

## 3. 候选方案对比（结合本仓库约束）

### 3.1 继续使用 `mcp-local-rag`（后端：LanceDB）

适配度：高（建议保持为默认）

- 优点
  - MCP 兼容：可直接被 Codex/Claude 等客户端调用，无需你维护服务端协议与工具定义。
  - 本地嵌入与混合检索：语义召回 + 关键词 boost，对“术语/参数名/错误码/函数名”更友好。
  - 现有闭环完整：本仓库已固化入库/清理/评估/预热脚本与约定，替换的边际收益通常低于迁移成本。
- 缺点（主要集中在 Git 友好与环境依赖）
  - DB 是目录结构且会频繁变化；作为普通 Git 资产不友好。
  - 依赖 Node/npx（对部分环境是额外运维成本）。
- 建议
  - 继续将 `.vibe/local-rag/` 视作可重建缓存（维持现状）。
  - 若强需求要同步 DB：只考虑“发布快照”或 LFS，不进入日常提交流。

### 3.2 `local-faiss-mcp`（Python + FAISS，本地持久化）

适配度：中（需要 POC 验证）

- 优点（基于其公开说明）
  - Python 生态：减少对 Node/npx 的依赖。
  - 声明支持持久化存储、自动切块、可选重排（rerank），并提供 CLI。
- 风险/未知（必须实测，避免拍脑袋决策）
  - 持久化文件形态（单文件/多文件/是否可增量）不明，无法直接推断 Git 友好程度。
  - 与本仓库现有脚本/回归集/工具接口的兼容性需要逐项核对（例如工具名、参数结构、返回结构）。
- 建议
  - 仅作为“非自研替代候选”，用第 5 节的验收清单做一次小规模 POC 后再决策。

### 3.3 直接换成 Milvus Lite / Chroma / 其它向量库（缺少现成 MCP 服务端）

适配度：低（当前不建议）

- 关键原因不是库本身，而是集成成本：
  - 本项目的检索入口是 MCP 工具层；如果没有现成的 MCP server，你就需要自建服务端/工具协议/配置与脚本适配。
  - 这会直接违反本仓库铁律“能不造轮子就不造轮子”（新增维护面远大于潜在收益）。

结论：在找到成熟的“现成 MCP server + 可验证落盘形态”之前，不建议推进。

---

## 4. 推荐决策（对 `freqtrade_demo`）

默认决策：继续使用 `mcp-local-rag`，保持向量库为可重建缓存（Git 同步源数据，不同步向量库产物）。

当且仅当你有“向量库必须随 Git 同步”的硬需求，再在以下两条里二选一：

- B1：保留 `mcp-local-rag`，但把 DB 以“发布快照”方式分发（tag/release 或 Git LFS），避免污染主分支历史。
- B2：POC 通过后再替换为 `local-faiss-mcp`（仍然是非自研、MCP 兼容），并同步更新脚本与文档。

---

## 5. 可执行验收（30–60 分钟 POC 即可决策）

对每个候选（至少 `mcp-local-rag` vs `local-faiss-mcp`），按同一套输入输出对比：

1) 语料固定：从 `docs/` 与 `.vibe/knowledge/sources/` 选取固定 50–200 个文件（生成清单并固化，保证可重复）。

2) 构建对比：
   - 全量构建一次；
   - 增量新增 1 个文件再构建一次（观察“改一处是否全盘重写”）。

3) 产物观察：
   - 落盘形态（单文件/目录、文件数）；
   - 总大小；
   - 增量更新后修改文件比例（用于评估 Git 友好性）。

4) 查询回归：复用 `docs/tools/vbrain/local_rag_eval_cases.json` 的 query（至少 Top-5 命中是否稳定，失败样例是否可解释/可改进）。

5) Windows 可用性：全程无需管理员权限、无需额外系统服务；首次模型下载后可离线运行。

建议门槛（可作为“通过/不通过”的硬标准）：

- 召回质量不低于当前（或至少同档）；失败案例可解释且可修复。
- 若要把向量库入库：增量更新不应导致 Git 历史膨胀不可控（否则应回退到“发布快照/LFS/重建缓存”策略）。
- 依赖链清晰可锁定（版本可 pin，升级路径可控）。

---

## 6. 相关文档

- 完整量化交易生态补充指南（本仓库基座版）：`docs/reports/quant_trading_full_stack_guide_2026-01-15_v1.0.md`
