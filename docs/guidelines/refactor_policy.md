# 架构与重构规范（一次性到位）

本文件用于固化本仓库的“重构方法论”：当我们判断某个问题属于**架构/设计层面的根因**时，不做分阶段迁移，而是一次性完成替换并收口，避免长期处于“旧系统 + 新系统并存”的不可控状态。

> 适用范围：目录结构、数据口径、研究/训练管线、策略执行闭环、命名体系、核心基础设施（factor engine / model loader / risk layer）等。

---

## 0) 不造轮子铁律（强制）

> 能不造轮子就不要造轮子。  
> 能不造轮子就不要造轮子。  
> 能不造轮子就不要造轮子。

这是本仓库的硬约束：在 vibe coding 里，我们追求的是**顶层设计 + 可验证闭环**，而不是“重复实现一个别人已经打磨过的库/框架”。

落地规则（写代码前必须完成）：

1. **先搜再写**：
   - 仓库内 `rg` 搜索（确认是否已有实现/相近模块/历史脚本）；
   - 在现有依赖里找（Freqtrade/Qlib/sklearn/pandas/numpy/stdlib）；
   - 需要查库文档时用 Context7。
2. **能复用就复用**：优先组合既有能力完成目标；禁止为了“统一风格”而重写成熟组件。
3. **必须造轮子先申请**（向维护者确认）：
   - 需求与边界（必须明确“不做什么”）；
   - 替代方案与失败原因（列表化、可复现）；
   - 维护与测试计划（含性能/边界/回归）；
   - 交付物（最小实现 + 单测 ≤60s + 文档 + 可复现命令）。

> 建议：若最终不得不自研，把“申请单”落到 `docs/reports/`，并在实现合入时附带链接，保证可追溯。

---

## 1) 核心原则（强制）

1. **一次性完成**：同一个变更中完成代码、脚本、配置、文档与测试的全量更新。
2. **单一主路径**：完成替换后只能保留一条“权威主路径”；禁止长期双轨运行。
3. **不保留兼容代码**：除非明确要求，否则不保留旧接口/旧命名/旧行为的兼容分支。
4. **可复现与可验收**：必须提供明确的复现命令与验收清单，确保新体系可用且可追溯。

---

## 2) 什么时候必须“彻底重构”

满足任意一条即视为“必须一次性到位”的重构：

- 同一概念出现多套命名/多套配置口径，导致协作与复盘成本持续上升。
- 主流程存在两套实现（例如研究层、训练层、执行层各自计算一套特征），产生“口径漂移”风险。
- 新方案引入后需要长期维护旧方案（双轨），且旧方案没有明确退役路径。
- 任何会影响收益/风控口径的基础设施（特征、标签、成本模型、漂移判定、执行策略）发生变化。

---

## 3) 一次性到位的提交清单（建议照抄）

在发起 PR/变更前，至少回答并落盘以下内容（建议写入 `docs/reports/change_summary_YYYY-MM-DD.md`）：

- 变更动机：为什么这是“根因”，不是小补丁？
- 影响面：涉及哪些目录（`docs/` / `scripts/` / `03_integration/` / `01_freqtrade/` / `04_shared/` / `tests/`）？
- 新的权威入口：新流程从哪里启动？旧入口如何处理（删除/改造成薄包装/迁移文档）？
- 复现命令：新流程最小可跑通命令是什么？
- 验收清单：哪些单测/脚本输出作为验收依据？

---

## 4) 反例（禁止）

- “先加一个新脚本试试，旧脚本先留着”：会让主线在一段时间内不可控。
- “为了兼容旧配置保留旧字段并自动兜底”：会让配置语义长期模糊。
- “只改代码不改文档/测试”：会让迁移不可复现，后续必然返工。
