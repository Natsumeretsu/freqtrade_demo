# 因子验证指南

**目标**：找到真正有效的 alpha 因子

---

## 📊 因子验证流程

```
1. 提出假设
   ↓
2. 数据准备
   ↓
3. 因子计算
   ↓
4. IC 分析
   ↓
5. 分位数分析
   ↓
6. 样本外测试
   ↓
7. 记录结果
```

---

## 1️⃣ 提出假设

**好的假设**：
- ✅ 明确的盈利逻辑（为什么能赚钱？）
- ✅ 可验证（有数据支持）
- ✅ 符合市场特性（加密市场 24/7 交易）

**示例**：
```
假设：短期动量在加密市场中有效期约 8 小时
理由：加密市场波动快，信息传播迅速
验证：计算 8 小时动量因子的 IC 值
```

---

## 2️⃣ 数据准备

```powershell
# 下载数据
cd 02_qlib_research/data_pipeline
python download.py --symbol BTC/USDT --timeframe 15m --days 90

# 数据清洗
python clean.py
```

**质量检查**：
- 无缺失值
- 无异常值（单根 K 线涨跌幅 < 20%）
- 时间连续

---

## 3️⃣ 因子计算

在 `03_integration/simple_factors/basic_factors.py` 中实现：

```python
def calculate_momentum(df: pd.DataFrame, window: int = 32) -> pd.Series:
    """
    动量因子

    假设：短期价格动量在加密市场中有效期约 8 小时（32 个 15 分钟 K 线）
    """
    return df['close'].pct_change(window)
```

---

## 4️⃣ IC 分析

**IC（信息系数）**：因子值与未来收益的相关性

```python
# 计算 IC
ic = factor.corr(future_return)

# 验收标准
assert ic > 0.05, "IC 太低，因子无效"
```

**IC 解读**：
- IC > 0.05：有效
- IC > 0.10：非常有效
- IC < 0.02：无效

---

## 5️⃣ 分位数分析

将因子值分为 5 组，观察各组的平均收益：

```python
# 分位数分组
df['quantile'] = pd.qcut(df['factor'], 5, labels=[1,2,3,4,5])

# 各组平均收益
df.groupby('quantile')['future_return'].mean()
```

**预期结果**：
- 第 5 组（因子值最高）收益最高
- 第 1 组（因子值最低）收益最低
- 单调性明显

---

## 6️⃣ 样本外测试

**数据分割**：
- 训练集：60%（用于因子开发）
- 验证集：20%（用于参数调优）
- 测试集：20%（用于最终验证）

**验收标准**：
- 测试集 IC > 0.05
- IC 衰减 < 30%（测试集 IC / 训练集 IC > 0.7）

---

## 7️⃣ 记录结果

在 `docs/reports/` 中记录：

```markdown
## 动量因子验证报告

**日期**：2026-01-18
**因子**：momentum_8h
**假设**：短期动量有效期 8 小时

### 结果
- 训练集 IC：0.08
- 验证集 IC：0.07
- 测试集 IC：0.06
- IC 衰减：25%

### 结论
✅ 通过验证，可用于策略
```

---

## ⚠️ 常见陷阱

### 1. 过拟合
- ❌ 在全部数据上调参
- ✅ 严格分离训练/验证/测试集

### 2. 前视偏差
- ❌ 使用未来数据计算因子
- ✅ 确保因子只使用历史数据

### 3. 幸存者偏差
- ❌ 只测试 BTC（最成功的币种）
- ✅ 测试多个币种

### 4. 数据窥探
- ❌ 多次查看测试集结果并调整
- ✅ 测试集只用一次

---

## 📚 参考资料

- Alphalens 文档：因子分析工具
- Empyrical 文档：性能指标计算
- 《量化投资：以 Python 为工具》

---

**最后更新**：2026-01-18
